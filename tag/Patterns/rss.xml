<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title></title>
   
   <link>https://digitalriding.de</link>
   <description>go down for deep diving into...</description>
   <language>de-ge</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Dependency Injection</title>
	  <link>//Dependency-Injection</link>
	  <author></author>
	  <pubDate>2019-01-26T00:00:00+00:00</pubDate>
	  <guid>//Dependency-Injection</guid>
	  <description><![CDATA[
	     <p>In der Welt der Software Architektur sind mit der Zeit einige Muster (engl. Patterns) entstanden,
womit man komplexe Probleme meistens auf die gleiche Art und Weise lösen kann.
Vielleicht sind dir einige dieser Patterns bereits bekannt, weil du davon gelesen oder sie angewendet hast.
Heute geht es um das sagenumwobene Design Pattern Dependency Injection (DI) zu deutsch  «Abhängigkeiten injizieren».
Was es nun genau mit DI auf sich hat, lieber Leser, das werde ich dir in diesem Artikel näher bringen. 
Nun ab ans Eingemachte!</p>

<h1 id="einführung">Einführung</h1>
<p>Dir gehen vielleicht gerade einige Fragen durch den Kopf.</p>
<ul>
  <li>Ist es mit SQL Injection verwandt?</li>
  <li>Ist mit Dependency eine Library gemeint die ein Programm verwendet?</li>
  <li>Kann mir eine Dependency injiziert werden?</li>
</ul>

<p>Die Antwort auf alle drei Fragen ist <strong>Nein</strong>!</p>

<p>Das Pattern DI wird im Kontext der objektorientierten Programmierung (OOP) gesehen.</p>

<p>Da wir uns in der OOP Objekte aus der realen Welt modellieren, versuche ich DI mal so zu erklären.
Nehmen wir mal einen Computer. Ein Computer besteht aus vielen Bauteilen. 
Platziert werden diese Bauteile auf dem Mainboard, dessen Aufgabe ist diese zu verbinden,
damit Informationen über elektrische Signale ausgetauscht werden können.</p>

<p><strong>Frage</strong>: Wer liefert Strom an das Mainboard?</p>

<p><em>Es ist das Netzteil.</em></p>

<p>Es wandelt den Wechselstrom in Gleichstrom um, damit alle Teile ordnungsgemäß arbeiten können.
Das tolle an der Sache ist, dass man nicht auf ein bestimmtes Netzteil eines Herstellers angewiesen ist.
Die Leistung (Watt) muss nur gleich oder höher dem des alten Netzteils entsprechen.<br />
D.h man muss eine Art Vertrag einhalten.</p>

<p><strong>Frage</strong>: Wie hält man Verträge beim Programmieren ein?</p>

<p><em>Mit Interfaces.</em></p>

<hr />

<p>Code technisch kann man es so darstellen</p>

<p>Deklaration von Interfaces</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface PowerSupply
interface Mainboard
</code></pre></div></div>

<p>Deklaration von Klassen</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class EightyPLUS : PowerSupply
class ATXFormat : Mainboard
</code></pre></div></div>
<p>ohne DI</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ATXFormat() : Mainboard {
    val powerSupply: PowerSupply = EightyPLUS()
}
</code></pre></div></div>
<p>mit DI</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class ATXFormat constructor(val powerSupply: PowerSupply) : Mainboard
</code></pre></div></div>

<p>Das Mainboard hat eine Abhangigkeit zum Netzteil. 
Das kann man so Ausdrücken <code class="highlighter-rouge">Mainboard -&gt; PowerSupply</code></p>

<h1 id="vorteile">Vorteile</h1>
<p>Ja die gibt es in der Tat. Wenn du dir das obige Beispiel nochmal anschaust, 
dann wirst du festellen, dass die Dependency nicht in der <code class="highlighter-rouge">ATXFormat</code> Klasse hard coded ist.
Ich kann somit ein verschiedenes Netzteil verwenden und bin nicht auf das eine angewiesen.</p>

<p>Ein weiterer Vorteil wird erst ersichtlich, 
nachdem der Abschnitt <a href="#verdrahtung-von-dependencies">Verdrahtung von Dependencies</a> gelesen wurde.</p>

<h1 id="brauche-ich-das">Brauche ich das?</h1>
<p>Da müssen wir uns erstmal Fragen, wann es denn überhaupt sinnvoll ist irgendeine Art von Design Pattern anzuwenden.
Ich antworte mit unser aller Lieblings Antwort: <strong>Es kommt drauf an</strong>.</p>

<p>Oft ist es so, dass man etwas über ein Pattern liest, aber dann gar nicht weiß, ob es sinnvoll für einen selbst anwendbar ist.
Das ist auch nachvollziehbar, wenn man noch nicht an etwas größeren Projekten gearbeitet hat. 
Fakt ist aber das Software ab einer gewissen Größe unheimlich komplex wird, sowohl technisch als auch in der Domäne.
Es treten dann Probleme auf, wofür schlaue Köpfe längst eine Musterlösung parat haben.
Diese Musterlösungen wurden festgehalten und als Buch veröffentlicht. 
Für alle die es interessiert es ist das Buch “Design Patterns. Elements of Reusable Object-Oriented Software”.</p>

<p>Sry für den kleinen Abschweif. Das soll kein Aufsatz über Design Patterns an sich werden.</p>

<p>Nun zurück zum wesentlichen. Wenn du ein kleines Programm schreibst, dann werden die Vorteile nicht ersichtlich sein.
Ein Objekt was du konstruiert hat entweder primitive Typen oder ein bis zwei weitere Objekte als Parameter.
Bevor man dann ins Overengineering (Aufwand ist höher als der Nutzen) kommt, kann man es auch so lassen.
Wenn du aber weißt dass in Zukunft noch einiges dran gemacht wird und das Programm wachsen wird, 
dann kann man vorsorgen und DI kann seine stärken ausspielen.</p>

<h1 id="arten">Arten</h1>
<p>Es gibt verschiedene Arten dieses Pattern umzusetzen.</p>

<h2 id="setter-injection">Setter Injection</h2>
<p>Das läuft wie der Name es schon vermuten lässt, über eine Setter Methode.</p>

<h2 id="field-injection">Field Injection</h2>
<p>Bekannt in der Java Welt durch Annotationen.
Über eine Annotation wird die Dependency zur Laufzeit verdrahtet.</p>

<h2 id="das-einzig-wahre-constructor-injection">Das einzig Wahre: Constructor Injection</h2>
<p>Jap. Es ist nunmal so. Ich erkläre dir auch wieso.</p>

<p>Konstruktoren sind aus einem gewissen Grund dar. Nachdem du ein Objekt instanziiert hast, sollte es in einem konsistenten Zustand sein.
Mit Setter Methoden kann man das nicht erreichen. Man kann z.B. NullPointerExceptions bekommen, 
wenn man eine Methode aufruft, die eine Property benutzt, die noch nicht gesetzt wurde.</p>
<blockquote>
  <p>Du kannst natürlich Setter Methoden anbieten, wenn du zur Laufzeit irgendwas ändern möchtest.</p>
</blockquote>

<p>Ein weiterer Grund betrifft Unit Tests. 
Bei Field Injection kannst du nicht so ohne weiteres ein Platzhalter (Stub) einsetzen.
Das ist wiederum bei Settern gar kein Problem.</p>

<p>Wenn man das ganze betrachtet bleibt nur noch Constructor Injection übrig.</p>

<blockquote>
  <p>Das habe ich übrigens auch im ersten Codebeispiel verwendet.</p>
</blockquote>

<h1 id="verdrahtung-von-dependencies">Verdrahtung von Dependencies</h1>
<p>Dependencies müssen untereinander verdrahtet werden.
Dabei können unterschiedliche Strukturen entstehen die einen Graphen repräsentieren (Dependency Graph).</p>

<p>Dependencies unter Objekten verlaufen selten linear, so wie in dem Beispiel <code class="highlighter-rouge">A -&gt; B -&gt; C</code>.</p>

<p>Oft ist es so, dass regelrechte Bäume entstehen</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     B -&gt; C
 A -&gt;         F
     D -&gt; E -&gt;
              G
</code></pre></div></div>
<p>Das war jetzt nur ein simples Beispiel. In der Praxis ist sowas Standard.</p>

<p>Mit dem Mantra im Sinn, das Klassen nicht allzu groß werden dürfen und somit alles aufgesplittet wird,
können regelrechte Abhängigkeits Explosionen entstehen.
Diese Strukturen von Hand zu Verdrahten ist nicht ohne.
Und zugegebenermassen, wir Informatiker sind faul. 
Da wir uns das Leben einfacher machen wollen, 
gibt es auch bereits eine Lösung dafür und zwar Inversion of Control Container.</p>

<h1 id="di--ioc">DI != IoC</h1>
<p>Inversion of Control (IoC) zu Deutsch «Umkehrung der Steuerung» lässt den Benutzer in den Vordergrund treten.
Nehmen wir mal eine Konsolenprogramm welches deine Eingabe erfordert.
Das Programm steuert den Fluss deiner Interaktion. 
Zu keinem Zeitpunkt kannst du deine Adresse angeben, wenn dein Name gefordert wird.
In einer GUI sieht es anders aus, da du jedes Feld in beliebiger Reihenfolge füllen kannst. 
Da liegt die Macht in deiner Hand.</p>

<p>Betrachten wir das ganze eine Ebene tiefer. 
Nehmen wir mal Callbacks als Beispiel.
Wenn ein Event innerhalb deiner Applikation veroeffentlich wird oder wenn jemand auf einem Button in einer UI klickt. 
Du als Client kannst selber bestimmen, was passieren soll, nachdem diese Aktion eingetreten ist.</p>

<p>DI ist nichts anderes als eine Form von IoC. 
Der Client hat hier die Verantwortung die Dependencies zu verdrahten und ist recht flexibel damit, 
weil es nicht hard coded ist.
Durch die Benutzung von Interfaces können jegliche Implementierungen genutzt werden.</p>

<h2 id="ioc-container">IoC Container</h2>
<p>Es gibt Libraries und Frameworks in gängigen Programmiersprachen, die solche IoC Container anbieten.
Nehmen wir mal Java als Beispiel, da ist das Spring Framework die erste Anlaufstelle.</p>

<p>Die wesentliche Aufgaben eines IoC Containers sind</p>
<ul>
  <li>Konstruierung des Dependency Graphs</li>
  <li>Life Cycle Management von Objekten (Man kann sich als Client in verschiedene Zyklen eines Objekts einhaken z.B. nachdem es konstruiert wurde)</li>
  <li>Injizierung von Konfigurations Werten</li>
</ul>

<h2 id="lets-program-an-ioc-container">Let’s program an IoC Container</h2>
<p>Da wir nun über die ganze Theorie bescheid wissen, wird’s jetzt richtig spannend.</p>

<p>Ich habe einen simplen IoC Container in Kotlin programmiert.
Das Beispiel ist etwas länger geworden und somit habe ich ein Repository auf GitHub angelegt.
Ich habe es da auch ausgiebig beschrieben und kommentiert, allerdings in Englisch.</p>

<p>https://github.com/Valefant/Addict</p>

<h1 id="ende">Ende</h1>
<p>Ich hoffe du konntest einiges aus diesem Artikel mitnehmen.
Falls ihr weitere Vorschläge habt welche Themen wir als nächste behandeln sollen, gebt uns bitte Bescheid. :-)</p>

<p>Mach dich jedenfalls auf den nächsten Artikel gefasst, denn da nehmen wir WebSockets näher unter die Lupe.</p>

	  ]]></description>
	</item>


</channel>
</rss>
