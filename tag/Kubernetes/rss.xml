<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title></title>
   
   <link></link>
   <description>go down for deep diving into...</description>
   <language>de-ge</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Einführung in den Einsatz von Kubernetes</title>
	  <link>//Einstieg-Kubernetes</link>
	  <author></author>
	  <pubDate>2018-04-21T08:30:00+00:00</pubDate>
	  <guid>//Einstieg-Kubernetes</guid>
	  <description><![CDATA[
	     <h2 id="wichtigsten-begrifflichkeiten">Wichtigsten Begrifflichkeiten</h2>

<table>
  <thead>
    <tr>
      <th>Begriff</th>
      <th>Erklärung</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Label</td>
      <td>Benutzt um Ressourcen zu klassifizieren.  Zum filtern, organisieren und für massen Operationen.</td>
    </tr>
    <tr>
      <td>Selector</td>
      <td>Zum selektieren anhand von Labels. Kannst du z.B. in den YAML-Files verwenden.</td>
    </tr>
    <tr>
      <td>Replication Controller</td>
      <td>Managed die Lebenszyklen von pods. Stellt z.B. sicher das immer genug Instanzen laufen.</td>
    </tr>
    <tr>
      <td>Service</td>
      <td>Sitzt quasi über den Pods und gibt denen eine IP Adresse und DNS-Name. Ist eine Load Balancing Konfiguration.</td>
    </tr>
    <tr>
      <td>Pod</td>
      <td>Eine Gruppe von Containern and deren Storage</td>
    </tr>
    <tr>
      <td>Cluster</td>
      <td>Set von Maschinen (physikal oder virtuell) auf denen die Anwendungen gemanaged werden und laufen.</td>
    </tr>
    <tr>
      <td>Deployment</td>
      <td>Gibt Kubernetes an wie Instanzen der Anwendung erstellt und geupdatet werden. <br /> (Hat einen Selbstheilungseffekt, fällt ein Node aus, merkt dieser das automatisch und gleicht aus.)</td>
    </tr>
  </tbody>
</table>

<h2 id="wichtigsten-befehle">Wichtigsten Befehle</h2>

<table>
  <thead>
    <tr>
      <th>Begriff</th>
      <th>Erklärung</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>kubectl get services</td>
      <td>Alle services im Namespace</td>
    </tr>
    <tr>
      <td>kubectl get pods -o wide</td>
      <td>Alle pods im Namespace mit mehr details</td>
    </tr>
    <tr>
      <td>kubectl get deployment loginservice</td>
      <td>Listet das Deployment mit dem Namen loginservice auf.</td>
    </tr>
    <tr>
      <td>kubectl describe services loginservice</td>
      <td>Detailierte Informationen über den Service loginservice</td>
    </tr>
    <tr>
      <td>kubectl expose deployment loginservice –type=LoadBalancer –name=loginservice</td>
      <td>Gibt den kompletten Pod über einen externen Endpunkt frei.</td>
    </tr>
  </tbody>
</table>

<h1 id="beispiel-vorgang">Beispiel Vorgang</h1>
<p>Automated build für github -&gt; docker einrichten <a href="https:pierrewilken.de/2018/04/21/Build-Pipeline-Docker-und-Github.html" rel="build pipeline github docker">Build Pipeline: github -&gt; docker</a></p>

<h3 id="in-der-kubernetes-ui-ein-secret-für-den-dockerhub-login-hinterlegen">In der Kubernetes-UI ein Secret für den Dockerhub-Login hinterlegen</h3>
<p>In die Kubernetes CLI gehen</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl create secret docker-registry &lt;SecretName&gt; <span class="nt">--docker-server</span><span class="o">=</span>&lt;your-registry-server&gt; 
<span class="nt">--docker-username</span><span class="o">=</span>&lt;your-name&gt; <span class="nt">--docker-password</span><span class="o">=</span>&lt;your-pword&gt; <span class="nt">--docker-email</span><span class="o">=</span>&lt;your-email&gt;
</code></pre></div></div>
<p>Der Secret-Name muss nachher im YAML-File verwendet werden, damit dieser das Image aus dem private Repo beziehen kann.</p>
<h3 id="yaml-file-erstellen">YAML-File erstellen</h3>
<p>Einfach mit einem beliebigen Editor eine Datei .yaml erstellen.</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: loginservice-deployment
  labels: 
    app: loginservice
spec:
  replicas: 3
  selector:
    matchLabels:
      app: loginservice
  template:
    metadata:
      labels:
        app: loginservice
    spec:
      containers:
      - name: loginservice
        image: pierreros/loginservice:latest
        ports:
        - containerPort: 80
          name: http
      imagePullSecrets:
        - name: dockerhub
</code></pre></div></div>
<h3 id="yaml-file-zum-deployment-erzeugen-verwenden">YAML-File zum Deployment erzeugen verwenden</h3>
<p>In Kubernetes rein, oben rechts auf Create klicken.
Dann “Upload a YAML or JSON file” wählen und uploaden. Sollte irgendwas am YAML-File nicht stimmen, meldet er sich.</p>

<p>Nun werden automatisch die Instanzen anhand des Images + der YAML-Einstellungen erstellt. Es wird immer automatisch dafür gesorgt das die Anzahl der Replicas korrekt ist, fällt also z.B. ein Node aus, erstellt er eine neue Instanz auf einem anderen Node.</p>

<p>Unsere Instanzen sind nun als pods auf unterschiedlichen Hosts intern ansprechbar. Von extern sind diese jedoch nicht zugänglich.</p>

<h3 id="den-erstellten-loginservice-nun-auch-von-extern-zugänglich-machen">Den erstellten loginservice nun auch von extern zugänglich machen</h3>
<p>Hierfür müssen wir einen service erstellen, dieser bildet in unserem Fall einen öffentlichen Endpunkt für alle loginservice Instanzen ab.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl expose deployment loginservice <span class="nt">--type</span><span class="o">=</span>LoadBalancer <span class="nt">--name</span><span class="o">=</span>loginservice 
</code></pre></div></div>

<p>Die Anfragen werden automatisch an die einzelnen Instanzen verteilt.</p>

	  ]]></description>
	</item>


</channel>
</rss>
