<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title></title>
   
   <link>https://digitalriding.de</link>
   <description>go down for deep diving into...</description>
   <language>de-ge</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Ein täuschender Stellvertreter namens John Proxy</title>
	  <link>//Proxy-Introduction</link>
	  <author></author>
	  <pubDate>2019-01-15T00:00:00+00:00</pubDate>
	  <guid>//Proxy-Introduction</guid>
	  <description><![CDATA[
	     <p>Lieber Leser, ich weiß dass die Überschrift auf eine spannende Geschichte hindeutet, 
indem John Proxy wahrscheinlich ein unglaublich gutaussehender Hauptprotagonist wäre, der in Wahrheit ein anderes Leben führt, als vorher angenommen. 
Ich muss dich leider enttäuschen. Es geht wirklich nur um Netzwerk Proxies. 
Es lohnt sich aber weiterzulesen, denn du kannst hier einiges lernen und langweilig wird es auch nicht. Versprochen!</p>

<h2 id="einführung">Einführung</h2>
<p>Es kam sicher mal vor, dass du einen Inhalt aufrufen wolltest, der in deinem Land nicht verfügbar war. 
Um solch eine Sperre zu umgehen werden oft Proxies benutzt. Proxy ist ein englischer Begriff und bedeutet übersetzt Stellvertreter. 
Dieser Begriff wird in der Informatik noch den Design Patterns zugeordnet (Proxy Pattern).</p>

<h3 id="was-ist-ein-proxy">Was ist ein Proxy?</h3>
<p>Ein Proxy ist ein Knotenpunkt im Netzwerk, der Pakete entgegennimmt und diese dann an ein Ziel weiterleitet. 
Er gibt sich somit als Stellvertreter des ursprünglichen Senders aus.
Der Empfänger sendet die Antwort zum Proxy, der wiederum das Paket zum ursprünglichen Sender schickt.</p>

<h3 id="aufgabengebiete">Aufgabengebiete</h3>
<p>Die Aufgaben eines Proxies sind vielseitig, da man recht viel damit anstellen kann.
Hier mal eine kleine Auflistung:</p>
<ul>
  <li>Verschleierung von IP-Adressen</li>
  <li>Sperrung von bestimmten Webseiten innerhalb eines Netzwerkes</li>
  <li>Caching von Inhalten z.B. Webseite</li>
  <li>Abschottung mehrere Server durch einen Reverse Proxy</li>
</ul>

<h3 id="welche-arten-gibt-es">Welche Arten gibt es?</h3>
<p>Proxies werden oft im Zusammenhang mit dem Web gebracht, da man sie da recht häufig nutzt. 
Um da nochmal eine bessere Unterscheidung zu machen werde ich von Web-Proxy sprechen, 
wenn es sich um Proxies handelt die mit HTTP zu tun haben, da Proxy ein übergeordneter Begriff ist.</p>

<p>Im folgenden werden die verschiedenen Proxy Typen näher beschrieben.</p>
<h4 id="transparenter-proxy">Transparenter Proxy</h4>
<p>Transparente Proxies offenbaren, dass die jeweilige Anfrage von dir versendet wurde. 
Zudem erkennt man die IP-Adresse des Senders. Diese Information findet man im HTTP Header mitunter als <code class="highlighter-rouge">X-Forwarded-For</code>.</p>

<h4 id="anonymer-proxy">Anonymer Proxy</h4>
<p>Anonyme Proxies offenbaren, dass die jeweilige Anfrage von dir versendet wurde. 
Die IP-Adresse des Senders wird allerdings nicht mit angegeben.</p>

<h4 id="elite-proxy">Elite Proxy</h4>
<p>Die Königsklasse sind die Elite Proxies, denn diese geben keine Information Preis.</p>

<h4 id="socks-sockets-proxy">SOCKS (SOCKetS) Proxy</h4>
<p>Im Vergleich zu den Web-Proxies ist ein SOCKS Proxy Protokollunabhängig und kann somit für weitere Dienste genutzt werden, beispielsweise für BitTorrent.</p>

<h4 id="reverse-proxy">Reverse Proxy</h4>
<p>Durch die Abschottung der Server ist der Reverse Proxy der einzige Eintrittspunkt.
Die abgeschotteten Server sind somit nicht Internet erreichbar. 
Zudem kann man einen Reverse Proxy als Load Balancer nutzen, der die jeweiligen Anfragen auf verschiedenen Servern einer Applikation verteilt.</p>

<h3 id="wie-funktioniert-das-ganze">Wie funktioniert das ganze?</h3>
<p>Du als Client musst die IP-Adresse des Web-Proxy Server kennen.
Deine Anfragen die du über HTTP stellst, werden dann über den Proxy geleitet.<br />
Dieser Web-Proxy Server untersucht den HTTP Header und kann dadurch die angefragte Ressource identifizieren.
Er stellt nun die Anfrage an den entsprechenden Server und liefert dir die Antwort zurück.</p>

<h2 id="du-lügst-doch-netflix-erkennt-wenn-ich-einen-elite-proxy-oder-vpn-dienst-benutze11">Du lügst doch. Netflix erkennt wenn ich einen Elite Proxy oder VPN Dienst benutze!!!!11</h2>
<p>Ok du hast mich erwischt. Es war alles von Anfang an nur eine Lüge!</p>

<h3 id="accountgebunden">Accountgebunden</h3>
<p>Bei der Registrierung von deinem Account, hast du wahrscheinlich noch keinen Proxy oder VPN Dienst nutzt. 
Zudem hast du eine deutsche Kreditkarte, streamst Inhalte aber aus Amerika. Ziemlich auffällig, meinst du nicht auch?</p>

<h3 id="gleiche-ip">Gleiche IP</h3>
<p>Ein VPN Anbieter hat eine Vielzahl von Servern die kunterbunt in aller Welt verteilt sind. 
Wenn mehrere Personen diesen VPN Anbieter benutzen, kann es vorkommen, dass du die gleiche IP-Adresse mit einer Person teilst. 
Beim abgleichen der Logs ist sowas recht schnell zu erkennen.</p>

<h3 id="blacklist">Blacklist</h3>
<p>Ich meine nicht die Serie (wobei die Serie ziemlich empfehlenswert ist), 
sondern eine Ansammlung von IP-Adressen die bekannt sind und von einem VPN Dienstleister kommen.
D.h man könnte wahrscheinlich einen großen Teil anhand einer Blacklist identifizieren. 
Es gibt sogar recht viele entsprechende APIs dafür.
Ich will natürlich keine Werbung machen, allerdings will ich meine Aussage nicht so stehen lassen. 
Ich habe jetzt beispielhaft zwei rausgesucht, es gibt aber noch einige mehr.</p>
<ul>
  <li><a href="https://iphub.info/">https://iphub.info/</a></li>
  <li><a href="https://www.neutrinoapi.com/api/ip-blocklist/">https://www.neutrinoapi.com/api/ip-blocklist/</a></li>
</ul>

<h3 id="active-proxy-checking">Active Proxy checking</h3>

<p>Es gibt sicherlich noch einige Kriterien die ich wahrscheinlich vergessen habe…</p>

<h2 id="abgrenzung-zu-vpns">Abgrenzung zu VPNs</h2>
<p><em>Ein Elite Proxy kostet mich doch nichts. Wieso sollte ich ein VPN Dienst nutzen?</em>
Berechtigte Frage. Schauen wir uns beides mal im Detail an.</p>

<p>Es gibt Applikationen an denen man einstellen kann, ob man einen Proxy verwenden möchte. 
Man kann auch im Betriebssystem selber einstellen, für welches Protokoll ein Proxy genutzt werden soll.
Das ist auch schon der erste Punkt der grundlegend anders ist, denn wir reden von einer Applikation oder einem Protokoll. 
Wenn wir von einer kompletten Verschlüsselung Gebrauch machen wollen, kommen wir um ein VPN nicht drum herum.</p>

<p>Über VPN wird im besten Fall die ganze Netzwerkkommunikation geleitet und somit <strong>verschlüsselt</strong>. 
Ich habe verschlüsselt fett gedruckt, da man immer bedenken muss, dass Netzwerkpakete immer adressiert sind. 
D.h die Teilstrecke ist verschlüsselt, da man ja am Ende einen Inhalt abfragen möchten. 
Der DNS Server muss ja die DNS Anfrage interpretieren können. 
Der Weg von dir zu deinem VPN Dienstleister ist auch ersichtlich nur sind die Daten von deinem ISP nicht einsehbar.</p>

<p>Wenn man VPN benutzt, dann gibt meist eine dazugehörige Applikation (auch als Smartphone App des öfteren) vom Dienstleister, 
um weitere Einstellungen vorzunehmen. Man kann z.B. auswählen welchen Server man von welcher Nation benutzen möchte, ob man in Intervallen die Server wechselt etc.</p>

<p>VPN ist allerdings auch kein heiliger Gral, da du dir nie sicher sein kannst, ob ein Unternehmen deinen Traffic loggt oder nicht.
Glaube nicht immer was auf deren Seite steht, denn es ist letztendlich ein Unternehmen und ist auf Gewinn aus.</p>

<blockquote>
  <p>Denn wie war das nochmal? Daten sind der Rohstoff des 21. Jahrhunderts.</p>
</blockquote>

<h3 id="anonymität">Anonymität</h3>
<p>Das ist ein sehr komplexes Thema, worüber man einige Bücher schreiben könnte.
Es ist unheimlich schwierig wahre Anonymität zu erhalten, denn dafür muss man unheimlich viele Variablen in Betracht ziehen.
Man muss sein Verhalten ändern, entsprechende Programme nutzen und ständig up to date sein. 
Es kann nämlich ziemlich schnell passieren, dass man etwas preisgibt, was man versucht hat zu verschleiern.
Beispielsweise gibt es Browser Plugins die deine IP-Adresse leaken können. 
Berühmte Vertreter waren Flash und Java, finden allerdings heute zum Glück nicht mehr viel Anwendung. 
Zudem gibt es weitere Protokolle wie WebRTC, welches auch mal eben die IP-Adresse leaken kann.</p>

<p>Nahezu jeder Benutzer kann schon alleine anhand eines einzigartigen Fingerabdrucks des Browsers ermittelt werden. 
Hier teste mal selbst 
<a href="https://firstpartysimulator.net">https://firstpartysimulator.net</a></p>

<p>Falls weiteres Interesse an dem Thema besteht, würde ich einen Artikel dazu schreiben der sich nur dem Thema widmet.</p>

<h2 id="beispiele">Beispiele</h2>
<h3 id="deep-packet-inspection">Deep Packet Inspection</h3>
<p>Ein Bild von einem HTTP Header, der von einem transparenten Proxy gesendet wurde.
Der Eintrag <code class="highlighter-rouge">X-Forwarded-For</code> zeigt dies.
<img src="/assets/images/screenshots/proxy/deep-packet-inspection.png" alt="Deep Packet Inspection" /></p>

<p>Die folgenden Codebeispiele sind in der Sprache Kotlin geschrieben und sollen mal kurz demonstrieren,
wie man einen Proxy erkennt bzw. einen selber implementiert. Dependencies die ich benutzt habe sind: <code class="highlighter-rouge">Javalin</code> und <code class="highlighter-rouge">khttp</code></p>

<h3 id="auslesen-der-nutzer-ip-bei-einem-transparenten-proxy">Auslesen der Nutzer IP bei einem transparenten Proxy</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun extractIp(request: HttpServletRequest): String {
    return request
            .getHeaders("X-Forwarded-For")
            .toList()
            .let { if (it.isEmpty()) request.remoteAddr else it.first { ip -&gt; ip != request.remoteAddr } }
}
</code></pre></div></div>

<h3 id="bestimmung-der-verwendung-bei-einem-transparenten-und-anonymen-proxy">Bestimmung der Verwendung bei einem transparenten und anonymen Proxy</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun usingProxy(request: HttpServletRequest): Boolean {
    return request
            .getHeaders("X-Forwarded-For")
            .toList()
            .isNotEmpty()
}
</code></pre></div></div>

<h3 id="eine-sehr-triviale-implementierung-eines-transparenten-proxies-für-das-http-verb-get">Eine sehr triviale Implementierung eines transparenten Proxies für das HTTP Verb GET</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proxyServer.get("/*") { ctx -&gt;
    val request = ctx.req
    val queryString = if (request.queryString.isNullOrEmpty()) "" else "?${request.queryString}"
    val response = get("${request.requestURL}$queryString")
    response.headers.forEach {name, value -&gt; ctx.header(name, value)}
    ctx.header("X-Forwarded-For", request.remoteHost)
    ctx.result(response.text)
}
</code></pre></div></div>

<h2 id="ende">Ende</h2>
<p>Ich hoffe du hast dich nicht gelangweilt und ich konnte mein Versprechen halten. Falls ihr Themenvorschläge habt, gebt uns bitte Bescheid. :-)</p>

<p>Man sieht sich im nächsten Artikel der sich um <strong>Dependency Injection</strong> handeln wird!</p>

	  ]]></description>
	</item>

	<item>
	  <title>Server Hardening - SSH</title>
	  <link>//Server-Hardening-SSH</link>
	  <author></author>
	  <pubDate>2018-10-12T00:00:00+00:00</pubDate>
	  <guid>//Server-Hardening-SSH</guid>
	  <description><![CDATA[
	     <p>Mietest du einen Server? Wenn ja, hast du ihn so eingerichtet, dass du dir sicher sein kannst, dass nur befugte Personen zugreifen können? Was ist wenn ich dir erzähle, dass ständig jemand versucht über Brute-Force dein SSH Login zu erhalten? Das ganze kann man ganz leicht selber nachprüfen</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ tail -f /var/auth.log
</code></pre></div></div>
<p>und einfach mal für eine kurze Zeit beobachten.</p>

<p>Viele Leute scheren sich nicht das initiale Passwort zu ändern, einen neuen Benutzer anzulegen oder SSH angemessen zu konfigurieren. Wundern sollte man sich dann allerdings nicht, wenn man nach einiger Zeit nicht mehr auf den Server zugreifen kann.</p>

<h2 id="was-ist-diese-secure-shell">Was ist diese Secure Shell?</h2>
<p>Es ist ein Netzwerkprotokoll, was auf TCP aufbaut. Es wird benutzt, um eine verschlüsselte Verbindung zu einem Server herzustellen. Die Shell eines entfernten Computers steht einem somit zur Verfügung. Implementiert ist das ganze als klassisches Client - Server Modell.</p>

<h2 id="wie-es-nicht-sein-sollte">Wie es nicht sein sollte</h2>
<p>Man bekommt von seinem Anbieter den Benutzer und das Passwort mitgeteilt, um sich über SSH anzumelden. Der Benutzer ist in der Regel root.</p>

<p>Diese Anmeldeinformationen sollte man allerdings nur bei der ersten Anmeldung nutzen.</p>

<blockquote>
  <p>Das ist genauso wie den Internet Explorer zu benutzen, um einen anderen Browser herunterzuladen.</p>
</blockquote>

<h2 id="der-übermächtige-root">Der übermächtige root</h2>
<p>Es ist keine gute Idee ständig als root unterwegs zu sein. Der root Benutzer hat jegliche Rechte auf dem System und so kann es mal schnell vorkommen, dass man irgendein Befehl oder Befehlskette ausführt die dir deinen Server zerschießen.</p>

<p>Deshalb ist es keine schlechte Idee einen neuen Benutzer anzulegen!</p>

<h2 id="ein-neuer-benutzer">Ein neuer Benutzer</h2>
<p>Da wir also nicht ständig als root unterwegs sein wollen, erstellen wir uns einen neuen Benutzer.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ adduser username
</code></pre></div></div>

<p>Eben ein Passwort festlegen und voilà, der neue Benutzer existiert.</p>

<p>Um unseren neuen Benutzer zu ermöglichen Programme zu nutzen, die nur dem root zugeschrieben sind, muss folgendes geschehen</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ usermod -aG sudo username
</code></pre></div></div>

<p>Wir können nun zum neu angelegten Benutzer wechseln</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ su - username
</code></pre></div></div>

<h2 id="schlüsselpaar-generieren">Schlüsselpaar Generieren</h2>

<p>Es werden zwei Schlüssel generiert. Ein öffentlicher und ein privater Schlüssel. Der öffentliche Schlüssel befindet sich nachher auf dem Server. Der private Schlüssel befindet sich auf der Maschine, von wo du dich aus mit dem Server verbindest.</p>
<blockquote>
  <p>An dieser Stelle sollte darauf hingewiesen werden, dass der private Schlüssel nur <strong>dir</strong> bekannt sein sollte.</p>
</blockquote>

<h4 id="linuxunix">Linux/Unix</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ssh-keygen -b 4096
</code></pre></div></div>

<p>Mit 4096 Bit gehen wir mal auf Nummer sicher.  Im anschließenden Dialog wirst du gefragt, ob du ein Passwort festlegen möchtest. Das ist an dieser Stelle dir selbst überlassen.</p>

<h4 id="windows">Windows</h4>
<p>Wenn das Windows Subsystem for Linux (WSL) aktiviert oder Cygwin installiert ist, dann läuft das Prozedere wie im <a href="#linuxunix">Linux/Unix</a> Abschnitt ab. Falls nicht kann ein graphisches Programm wie PuTTYgen verwendet werden.</p>

<h2 id="keys-übertragen">Keys Übertragen</h2>
<p>Der öffentliche Schlüssel muss zum Server übertragen werden. Das kann auf zwei Arten geschehen, wovon die erste aufgezeigte komfortabler ist.</p>

<p><em>Nr 1.</em></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ssh-copy-id username@server_ip
</code></pre></div></div>

<p><em>Nr 2.</em>
Den Inhalt des öffentlichen Schlüssels in den Zwischenspeicher packen</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ssh username@server_ip
$ nano ./ssh/authorized_keys
</code></pre></div></div>
<p>und dann am Besten ans untere Ende in einer neuen Zeile einfügen.</p>

<blockquote>
  <p>Falls das Verzeichnis <code class="highlighter-rouge">.ssh</code> und die Datei <code class="highlighter-rouge">authorized_keys</code> nicht existieren, dann kann man sie per Hand anlegen.</p>
</blockquote>

<p>Wenn bei der erneuten Anmeldung über SSH die Passwortabfrage entfällt, hat das ganze funktioniert.</p>

<h2 id="ssh-konfigurationsdatei">SSH Konfigurationsdatei</h2>
<p>Konfigurationsdateien von Diensten befinden sich bei unixoide System im Verzeichnis <code class="highlighter-rouge">/etc</code>. In unserem Falle passen wir die <code class="highlighter-rouge">/etc/ssh/sshd.config</code> an.</p>

<p>Bevor wir die Datei anpassen, bitte ich darum, dass eine Kopie angelegt wird.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo cp /etc/ssh/sshd.config /etc/ssh/sshd.config.bak
</code></pre></div></div>

<h3 id="konfiguration">Konfiguration</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo nano /etc/ssh/sshd.conf 
</code></pre></div></div>

<p>Damit wird die neuere Version des Protokolls benutzen</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Protocol 2
</code></pre></div></div>

<p>Als root sollte man sich nicht mehr über SSH anmelden sollen, denn das ist der naheliegendste Benutzern, den ein Angreifer benutzt, um sich einzuwählen.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PermitRootLogin no
</code></pre></div></div>

<p>Hat das mit den Schlüsseln funktioniert? Dann sollte auf ein Passwort verzichtet werden. Damit fällt einer der größten Angriffsvektoren raus.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PasswordAuthentication no 
</code></pre></div></div>

<p>Nur der Benutzer, den du im Abschnitt <a href="#ein-neuer-benutzer">Ein neuer Benutzer</a> erstellt hast, darf sich über SSH einloggen.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AllowUser username
</code></pre></div></div>

<p>Nachdem alle Anpassungen vorgenommen werden, muss der SSH Dienst neu gestartet werden. So gehts beispielsweise unter Ubuntu</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo systemctl reload sshd
</code></pre></div></div>

<h2 id="ssh-port">SSH Port</h2>
<p>Der Port des SSH Servers kann geändert werden. Das geschieht ebenfalls in der Konfigurationsdatei. Man könnte an dieser Stelle denken, dass man dem Angreifer damit ein Strich durch die Rechnung macht. Allerdings muss an dieser Stelle festgehalten werden, dass das faktisch nicht viel bringt.</p>

<p>Es ist trivial standardisierte Dienste  zu ermitteln und das zeigt z.B. ein einfacher Port Scan mit <code class="highlighter-rouge">nmap</code>.</p>

<p>Wenn man sich über einen TCP Client mit einem Server verbindet, worauf ein SSH Dienst läuft, erhält man so eine Antwort.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ nc sdf.org 22
$ SSH-2.0-OpenSSH_7.1
</code></pre></div></div>
<blockquote>
  <p>Das ist der Protokoll Anfang, in dem der Server dem Client mitteilt, welche SSH Protokoll Version  benutzt wird, um im folgenden weiter zu kommunizieren.</p>
</blockquote>

<h2 id="zusätzliche-absicherung-mit-fail2ban">Zusätzliche Absicherung mit Fail2Ban</h2>
<p>Mit diesem tollen Programm kann man die IP von unerwünschte Gäste automatisch sperren lassen, die innerhalb eines festgelegten Zeitintervalls eine Anzahl an Anmeldeversuchen überschritten haben.</p>

<h3 id="installation">Installation</h3>
<p>Unter Debian Distributionen</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo apt install fail2ban
</code></pre></div></div>

<h3 id="konfiguration-1">Konfiguration</h3>
<p>Wieder sollte eine Kopie angelegt werden, bevor wir etwas anpassen.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo cp /etc/fail2ban/jail.conf /etc/fail2ban/jail.local
</code></pre></div></div>

<p>Die <code class="highlighter-rouge">jail.local</code> überschreibt jegliche Werte, die in der <code class="highlighter-rouge">jail.conf</code> definiert sind. Diese sollte verwendet werden, um Anpassungen vorzunehmen</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo nano /etc/fail2ban/jail.local
</code></pre></div></div>

<p>Es ist existiert schon ein SSH Filter. Dieser muss nur noch aktiviert werden.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[sshd]
enabled=true
</code></pre></div></div>

<p>Nachdem alle Anpassungen vorgenommen werden, muss der fail2ban Dienst neu gestartet werden. So gehts beispielsweise unter Ubuntu</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo systemctl restart fail2ban
</code></pre></div></div>
<p>Jetzt zurücklehnen und einfach beobachten</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo tail -f /var/log/fail2ban.log
</code></pre></div></div>

<p>Vielleicht wäre es noch ganz interessant zu wissen, wie man gebannte IPs einsehen kann</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo cat /var/log/fail2ban.log | grep Ban
</code></pre></div></div>

<h2 id="ende">Ende</h2>
<p>Ich hoffe du konntest einiges aus diesem Blog Artikel mitnehmen. In Zukunft solltest du besser gewappnet sein :-)</p>

	  ]]></description>
	</item>


</channel>
</rss>
