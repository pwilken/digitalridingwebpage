<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title></title>
   
   <link></link>
   <description>go down for deep diving into...</description>
   <language>de-ge</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Scaffolding - Code aus bestehender Datenbank generieren (Firebird Datenbank)</title>
	  <link>//Database-to-code-firebird-de</link>
	  <author></author>
	  <pubDate>2018-04-21T08:45:00+00:00</pubDate>
	  <guid>//Database-to-code-firebird-de</guid>
	  <description><![CDATA[
	     <h1 id="database-to-code-mit-einer-existierenden-firebird-datenbank">Database to Code mit einer existierenden Firebird Datenbank</h1>
<p>Generieren von Models, Controller und Views in einer “ASP.Net Core Web Applikation” anhand existierender Firebird Datenbank.</p>

<h2 id="schritt-1-erstelle-eine-aspnet-core-web-applikation">Schritt 1: Erstelle eine ASP.Net Core Web Applikation</h2>

<h2 id="schritt-2-füge-die-folgenden-nuget-packages-hinzu">Schritt 2: Füge die folgenden nuget-packages hinzu</h2>
<ul>
  <li>EntityFrameworkCore.FirebirdSql</li>
  <li>Microsoft.AspNetCore.All</li>
  <li>Microsoft.NETCore.App</li>
  <li>Microsoft.VisualStudio.Web.CodeGeneration.Design</li>
</ul>

<h2 id="schritt-3-erstelle-und-speichere-den-connection-string-zu-deiner-datenbank">Schritt 3: Erstelle und speichere den connection string zu deiner Datenbank</h2>
<p>Using example values.</p>

<p>String for dbfilename.fdb</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s2">"User=sysdba;Password=masterkey;Database=/firebird/data/dbfilename.fdb;DataSource=127.0.0.1;
Port=3050;Dialect=3;Charset=NONE;Role=;Connection lifetime=15;Pooling=true;MinPoolSize=0;
MaxPoolSize=50;PacketSize=8192;ServerType=0;"</span>
</code></pre></div></div>

<h2 id="schritt-4-benutze-scaffold-um-dein-datenbank-model-zu-reversen">Schritt 4: Benutze Scaffold um dein Datenbank-Model zu reversen</h2>
<p>Benutze den folgenden Befehl mit deinen angepassten Werten, z.B. in VisualStudio in der Paketverwaltungs-Konsole.</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Scaffold-DbContext <span class="s2">"User=sysdba;Password=masterkey;Database=/firebird/data/dbfilename.fdb;
DataSource=127.0.0.1;Port=3050;Dialect=3;Charset=NONE;Role=;Connection lifetime=15;
Pooling=true;MinPoolSize=0;MaxPoolSize=50;PacketSize=8192;ServerType=0;"</span>
EntityFrameworkCore.FirebirdSQL <span class="nt">-o</span> Models
</code></pre></div></div>

<h2 id="schritt-5-generiere-die-controller-und-views">Schritt 5: Generiere die Controller und Views</h2>
<p>Rechtsklick auf Projekt -&gt; Add -&gt; New Scaffolded Item…
-&gt; MVC Controller with views, using Entity Framework</p>

<p><img src="http://pierrewilken.de/assets/img/dbtocode_fb.png" alt="Foo" /></p>

<p>Es wird eine data context Klasse für alle Models der Datenbank generiert.</p>

<h2 id="schritt-6-kleine-anpassungen">Schritt 6: Kleine Anpassungen</h2>
<p>Add in Startup.cs -&gt; ConfigureServices(IServiceCollection services)</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>services.AddDbContext&lt;_firebird_data_dbfilename_fdbContext&gt;<span class="o">(</span>
   options <span class="o">=&gt;</span> options.UseFirebird<span class="o">(</span>
   Database.GetConnectionString<span class="o">()</span>
 <span class="o">))</span><span class="p">;</span>
</code></pre></div></div>

<p>Füge den folgenden Konstruktor in _firebird_data_dbfilename_fdbContext hinzu.</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public _firebird_data_dbfilename_fdbContext<span class="o">(</span>DbContextOptions&lt;_firebird_data_dbfilename_fdbContext&gt; options<span class="o">)</span> 
                                            base<span class="o">(</span>options<span class="o">)</span>
<span class="o">{</span>            
<span class="o">}</span>
</code></pre></div></div>

<h2 id="schritt-7-genieße-die-resultate">Schritt 7: Genieße die Resultate</h2>
<p>Die Anwendung einfach ausführen und am ende der Url den Controller-Namen ohne “Controller” hinzufügen.
http://localhost:51710/AddContacts</p>


	  ]]></description>
	</item>

	<item>
	  <title>Einführung in den Einsatz von Kubernetes</title>
	  <link>//Einstieg-Kubernetes</link>
	  <author></author>
	  <pubDate>2018-04-21T08:30:00+00:00</pubDate>
	  <guid>//Einstieg-Kubernetes</guid>
	  <description><![CDATA[
	     <h2 id="wichtigsten-begrifflichkeiten">Wichtigsten Begrifflichkeiten</h2>

<table>
  <thead>
    <tr>
      <th>Begriff</th>
      <th>Erklärung</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Label</td>
      <td>Benutzt um Ressourcen zu klassifizieren.  Zum filtern, organisieren und für massen Operationen.</td>
    </tr>
    <tr>
      <td>Selector</td>
      <td>Zum selektieren anhand von Labels. Kannst du z.B. in den YAML-Files verwenden.</td>
    </tr>
    <tr>
      <td>Replication Controller</td>
      <td>Managed die Lebenszyklen von pods. Stellt z.B. sicher das immer genug Instanzen laufen.</td>
    </tr>
    <tr>
      <td>Service</td>
      <td>Sitzt quasi über den Pods und gibt denen eine IP Adresse und DNS-Name. Ist eine Load Balancing Konfiguration.</td>
    </tr>
    <tr>
      <td>Pod</td>
      <td>Eine Gruppe von Containern and deren Storage</td>
    </tr>
    <tr>
      <td>Cluster</td>
      <td>Set von Maschinen (physikal oder virtuell) auf denen die Anwendungen gemanaged werden und laufen.</td>
    </tr>
    <tr>
      <td>Deployment</td>
      <td>Gibt Kubernetes an wie Instanzen der Anwendung erstellt und geupdatet werden. <br /> (Hat einen Selbstheilungseffekt, fällt ein Node aus, merkt dieser das automatisch und gleicht aus.)</td>
    </tr>
  </tbody>
</table>

<h2 id="wichtigsten-befehle">Wichtigsten Befehle</h2>

<table>
  <thead>
    <tr>
      <th>Begriff</th>
      <th>Erklärung</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>kubectl get services</td>
      <td>Alle services im Namespace</td>
    </tr>
    <tr>
      <td>kubectl get pods -o wide</td>
      <td>Alle pods im Namespace mit mehr details</td>
    </tr>
    <tr>
      <td>kubectl get deployment loginservice</td>
      <td>Listet das Deployment mit dem Namen loginservice auf.</td>
    </tr>
    <tr>
      <td>kubectl describe services loginservice</td>
      <td>Detailierte Informationen über den Service loginservice</td>
    </tr>
    <tr>
      <td>kubectl expose deployment loginservice –type=LoadBalancer –name=loginservice</td>
      <td>Gibt den kompletten Pod über einen externen Endpunkt frei.</td>
    </tr>
  </tbody>
</table>

<h1 id="beispiel-vorgang">Beispiel Vorgang</h1>
<p>Automated build für github -&gt; docker einrichten <a href="https:pierrewilken.de/2018/04/21/Build-Pipeline-Docker-und-Github.html" rel="build pipeline github docker">Build Pipeline: github -&gt; docker</a></p>

<h3 id="in-der-kubernetes-ui-ein-secret-für-den-dockerhub-login-hinterlegen">In der Kubernetes-UI ein Secret für den Dockerhub-Login hinterlegen</h3>
<p>In die Kubernetes CLI gehen</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl create secret docker-registry &lt;SecretName&gt; <span class="nt">--docker-server</span><span class="o">=</span>&lt;your-registry-server&gt; 
<span class="nt">--docker-username</span><span class="o">=</span>&lt;your-name&gt; <span class="nt">--docker-password</span><span class="o">=</span>&lt;your-pword&gt; <span class="nt">--docker-email</span><span class="o">=</span>&lt;your-email&gt;
</code></pre></div></div>
<p>Der Secret-Name muss nachher im YAML-File verwendet werden, damit dieser das Image aus dem private Repo beziehen kann.</p>
<h3 id="yaml-file-erstellen">YAML-File erstellen</h3>
<p>Einfach mit einem beliebigen Editor eine Datei .yaml erstellen.</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apiVersion: apps/v1beta1
kind: Deployment
metadata:
  name: loginservice-deployment
  labels: 
    app: loginservice
spec:
  replicas: 3
  selector:
    matchLabels:
      app: loginservice
  template:
    metadata:
      labels:
        app: loginservice
    spec:
      containers:
      - name: loginservice
        image: pierreros/loginservice:latest
        ports:
        - containerPort: 80
          name: http
      imagePullSecrets:
        - name: dockerhub
</code></pre></div></div>
<h3 id="yaml-file-zum-deployment-erzeugen-verwenden">YAML-File zum Deployment erzeugen verwenden</h3>
<p>In Kubernetes rein, oben rechts auf Create klicken.
Dann “Upload a YAML or JSON file” wählen und uploaden. Sollte irgendwas am YAML-File nicht stimmen, meldet er sich.</p>

<p>Nun werden automatisch die Instanzen anhand des Images + der YAML-Einstellungen erstellt. Es wird immer automatisch dafür gesorgt das die Anzahl der Replicas korrekt ist, fällt also z.B. ein Node aus, erstellt er eine neue Instanz auf einem anderen Node.</p>

<p>Unsere Instanzen sind nun als pods auf unterschiedlichen Hosts intern ansprechbar. Von extern sind diese jedoch nicht zugänglich.</p>

<h3 id="den-erstellten-loginservice-nun-auch-von-extern-zugänglich-machen">Den erstellten loginservice nun auch von extern zugänglich machen</h3>
<p>Hierfür müssen wir einen service erstellen, dieser bildet in unserem Fall einen öffentlichen Endpunkt für alle loginservice Instanzen ab.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>kubectl expose deployment loginservice <span class="nt">--type</span><span class="o">=</span>LoadBalancer <span class="nt">--name</span><span class="o">=</span>loginservice 
</code></pre></div></div>

<p>Die Anfragen werden automatisch an die einzelnen Instanzen verteilt.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Aufsetzen einer Build Pipeline - Github zum Docker Hub</title>
	  <link>//Build-Pipeline-Docker-Github-de</link>
	  <author></author>
	  <pubDate>2018-04-21T08:00:00+00:00</pubDate>
	  <guid>//Build-Pipeline-Docker-Github-de</guid>
	  <description><![CDATA[
	     <p>Folgende Dinge werden für das Aufsetzen einer simplen Continues Integration und Delivery mit Github und dem Docker Hub benötigt:</p>
<ul>
  <li>Docker Hub Account</li>
  <li>Github Account</li>
  <li>Lauffähiges Projekt in Github mit Dockerfile</li>
</ul>

<h1 id="das-github-projekt-mit-dockerfile">Das Github Projekt mit Dockerfile</h1>
<h2 id="beispielprojekt-mit-dockerfile-net-core">Beispielprojekt mit Dockerfile (.Net Core)</h2>
<p>Das Dockerfile kann selbst geschrieben oder von Visual Studio erstellt werden. 
Auf das selbst schreiben werde ich demnächst detailiert in einem weiteren Beitrag eingehen.</p>

<p>Ihr könnt entweder z.B. dieses Projekt 
<a href="https://github.com/pwilken/dotnetcore-webservice-demonstration" rel="pwilken/dotnetcore-webservice-demonstration">pwilken/dotnetcore-webservice-demonstration</a>
nehmen oder ein selbst erstelltes als Github Repository verwenden.</p>

<h3 id="selbst-erstellen">Selbst erstellen</h3>
<p>In Visual Studio ein neues Projekt erstellen. 
Unter .Net Core den Typ “ASP.NET Core Web Application” auswählen und mit OK bestätigen.
In dem darauffolgenden Fenster “API” wählen und “Enable Docker Support” anhaken + “OS: Linux” auswählen.</p>

<p>Das Projekt könnt ihr, wenn ihr Docker lokal installiert habt und auf Linux Container gestellt habt, so schon lokal mit Docker testen.
Ihr könnt das Projekt aber auch so schon für die Build Pipeline als Repository zu Github hinzufügen. 
Für das Einrichten und Testen reicht das.</p>

<h1 id="einrichten-der-build-pipeline">Einrichten der Build Pipeline</h1>
<h2 id="vorzunehmende-einstellungen">Vorzunehmende Einstellungen</h2>
<p><a href="https://hub.docker.com/" rel="hub.docker">hub.docker</a> -&gt; Settings -&gt; Linked Accounts &amp; Services -&gt; Link Github -&gt; Public and Private -&gt; Authorize docker <br />
<a href="https://cloud.docker.com" rel="cloud.docker">cloud.docker</a> -&gt; Open a repository -&gt; Builds -&gt; Configure Automated Builds</p>

<p>Bei jeder Änderung (push) des Github-Repos, wird das Image nun neu gebuilded.</p>

<h2 id="docker-rechte-in-github">Docker Rechte in Github</h2>
<p>Die Rechte für das Docker Hub sind auf Github sichtbar und entfernbar unter:
Settings -&gt; Applications -&gt; Authorized OAuth Apps</p>

	  ]]></description>
	</item>


</channel>
</rss>
